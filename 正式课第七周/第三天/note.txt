MIME:每一种文件都有自己的类型,这个类型被称为MIME
  HTML: text/html
  CSS: text/css
  JS: text/javascript
  TXT: text/plain
  JSON: application/json
  GIF: image/gif
  PNG: image/png
  JPG: image/jpeg
  ...
==========================
我们在WB中预览页面的时候,WB会帮我们创建一个本地服务,端口号是63342,完成了我们SEVER.JS中处理的操作,但是一定要记住访问的不是我们自己创建的这个服务

==========================
1、HTTP事物
  REQUEST(请求阶段)+RESPONSE(响应阶段),两个阶段的事情都完成,本次HTTP请求的操作才算完成,才被称为一个HTTP事物

2、HTTP报文
  客户端传递给服务器的内容和服务器返回给客户端的内容统称为HTTP报文
    请求：客户端->服务器  客户端设置,服务器端获取

    响应: 服务器->客户端  服务器端设置,客户端获取

    起始行:请求起始行、响应起始行

    首部(头):通用头、请求头、响应头、自定义请求头、自定义响应头

    主体：请求主体、响应主体

  这些信息在谷歌浏览器的NetWork中都可以查看到

3、客户端都可以通过哪些方式把内容传递给服务器?
     问号传参：在请求的URL地址后面通过 ?xxx=xxx 的方式,把内容传递给服务器
     设置请求头：客户端把需要传递给服务器的内容放在请求头中，在HTTP传输的时候通过请求头把信息传递给服务器(例如：客户端把cookie信息传递给服务器一般都这么做)
     设置请求主体：客户端把信息放在请求主体中传递给服务器(例如：在POST系列请求中，由于传给服务器的内容比较多，我们一般都放在请求主体中传递给服务器)

   服务器通过哪些方式把内容传递给客户端?
     设置响应头：服务器把内容放在响应头中返回给客户端(例如：服务器的时间)
     设置响应主体：基本上服务器返回给客户端的主要内容信息都是放在响应主体中返回给客户端的

4、在以后项目中，如果发现某一个功能实现不了，不要着急，在NETWORK中看一下，客户端发送给服务器的数据是否正确，在看一下服务器给客户端返回的数据是否正确，以此来判断是客户端的BUG还是服务器端的BUG

===========================================
1、什么是AJAX?
  async javascript and xml:异步的JS和XML

  AJAX是干什么用的?
   我们在客户端的JS中可以使用AJAX技术向服务器发送一个请求，从服务器端把需要展示在页面中的数据获取到->主要实现的是客户端和服务器之间数据交互的
   按照AJAX的定义来看，客户端从服务器端获取的数据应该是XML格式的数据，但是真实项目中最常用的确实JSON格式的数据；所以客户端从服务器端获取的数据格式有多种：JSON格式/XML格式/文件流格式...

  异步JS->局部刷新
    全局刷新：那会AJAX还没有被应用呢，页面是由服务器渲染的，服务器把渲染完成的结果给客户端的浏览器展示。但是在页面中，我们的某些操作可能会导致页面中的内容发生改变，这样的话，服务器需要把最新渲染完成的页面重新的交给浏览器展示，这样浏览器需要把整个页面重新的刷新才可以。
    GMAIL(谷歌邮箱)率先应用AJAX技术，在这样在页面中在操作的时候，如果有一个区域需要重新的加载，我们只需要使用AJAX从服务器端获取最新的数据，然后单独的把这个区域重新的渲染即可->局部刷新

==========================================
HTML:超文本标记语言
XHTML:更加严谨的HTML,我们现在用的就是XHTML
HTML5:在原有HTML的基础上新增加很多的有助于开发的功能
DHTML:页面中的数据是由前端动态绑定的

XML:可扩展的标记语言,在XML中出现的标签都不是W3C规定的,而是自己根据需求扩展出来的 =>一般经常应用于存储数据
WXML:微信小程序的页面文件
==========================================
2、AJAX怎么用

  //->创建一个AJAX对象(实例)
  var xhr = new XMLHttpRequest();

  //->打开一个请求的URL地址:给AJAX对象做发送前的一些基础配置
  xhr.open([http method],[request url],[async:true(默认)/false],[user name],[user pass]);

  //->监听AJAX状态改变,在不同的状态下做不同的事情
  xhr.onreadystatechange=function(){
     //->xhr.readyState AJAX状态
     //->xhr.status 服务器响应的网络状态码
     //->xhr.responseText 服务器响应主体内容(字符串/JSON字符串)
     if(xhr.readyState===4 && xhr.status===200){
        var val=xhr.responseText;
     }
  }

  //->发送请求
  xhr.send([data]);

=================================
var xhr = new XMLHttpRequest(); //->在IE6及更低版本的浏览器中,不支持这个方法,需要使用new ActiveXObject(),在这个新的类中还需要传递三种不同的参数才可以

回去后看视频：课时137，重点看的不是怎么处理兼容，而是JS高阶编程技巧之惰性思想
课时168和169,回调函数深入+柯理化函数,回去后也要看,这个是JS深入的扩展
=================================
http method:HTTP请求方式
  不管是哪一种请求方式，客户端都可以给服务器传递内容，也可以从服务器获取内容

  [GET系列]
    GET:获取 ->给服务器的少，从服务器获取的多
    DELETE:删除 ->在服务器上删除某一个文件
    HEAD:头 ->应用于客户端只想获取服务器返回的响应头信息,响应主体不获取

  [POST系列]
    POST:推送 ->给服务器的多,从服务器获取的少,例如:用户注册
    PUT:放 ->在服务器上放一个文件

  GET系列和POST系列的区别:
    GET系列传递给服务器内容都是通过问号传参的方式传递过去的
      [GET]
        xhr.open('get','/temp.xml?name=zf&age=8');
        xhr.send(null);
    POST系列是通过请求主体传递给服务器的
      [POST]
        xhr.open('post','/temp.xml');
        xhr.send('{"name":"zf","age":8}');//->通过请求主体把JSON字符串传递给服务器

    1、传给服务器的内容GET少,GET系列请求在传递给服务器的内容上有限制
      GET是在URL末尾追加问号传参传递的，如果传递的内容过多，URL就会变的很长，但是浏览器都有一个最大URL长度的限制(谷歌8KB 火狐7KB IE2KB)
      POST理论上没有传递大小的限制,但是真实项目中为了保证传输的速度,我们自己会做限制(例如：限制上传的内容在xxxKB以内)

    2、安全问题
      GET不安全,POST相对安全,因为GET请求容易被URL劫持,导致传递给服务器的数据泄露

    3、缓存问题
      GET请求可能会产生缓存(我们不可控),POST不会
      想让在GET请求下也没有缓存，只需要在每一次请求URL的后面追加一个随机数/时间戳都可以
      xhr.open('get','/temp.xml?name=zf&_='+Math.random());

========================================
request url:请求地址，客户端是通过这个地址先找到服务器的对应服务和对应接口,然后发个请求获取自己需要的数据；真实项目中获取数据的这个地址都是后台开发者给前端的(API文档)

========================================
async:设置同步异步,默认是true,代表异步;写false代表同步;

========================================
userName & userPass:用户名密码,平时不用

========================================
AJAX状态:xhr.readyState
0 UNSENT 未发送,创建完成一个XHR的时候默认值就是0
1 OPENED 已打开,已经执行XHR.OPEN了
2 HEADERS_RECEIVED 客户端已经获取到服务器端返回的响应头信息了
3 LOADING 服务器响应主体的内容正在返回
4 DONE 服务器响应主体内容接收完成

AJAX请求数据这件事从XHR.SEND后开始,到xhr.readyState=4的时候才算结束

========================================
xhr.status:服务器响应状态码,服务器可以通过不同的码反映出最后的结果
  200 成功,以2开头的状态码都是成功

  301 永久重定向(永久转移)
  302 临时重定向=>处理服务器的负载均衡
  304 读取缓存数据(这个是我们自己在服务器上做的处理)

  400 请求参数错误
  401 无权限访问
  404 请求地址不存在   4开头都是客户端的错误

  500 未知的服务器错误
  503 服务器超负荷     5开头的都是服务器错误

==========================================
预习：
  课时141 ~ 课时152

















